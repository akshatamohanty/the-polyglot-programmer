# How to learn a language?

Languages are a prime component in a software developer's toolkit. Yes, the knowledge is often transferable. However, much like communicative languages, intimately knowing a language makes programming effortless, more expressive and creative.

This document breaks down learning a language into focus area. Each focus areas is elaborated upon for every language in this handbook.

## Intent, purpose and design philosophy

Every language is developer towards a purpose. The design draws inspiration from older languages, often combining features to get a more "powerful language". The purpose often determines much of the in-built semantics and functionality. Knowing this intent makes it easier for a developer to make an informed decision.

Components of a language

## Syntax and Grammar

Syntax is the set of rules of how code is written in the language. Grammar is the structure of the language's expression and statements. There are formal grammars that exist, such as Backus-Naur Form (BNF). BNF is a notation that describes the grammer of a language using production rules. The rules define how expressions and statements are formed from symbols, keywords and operators.

## Lexers, parsers and semantics

This component is probably not that important while using a language. However, learning these intrincis help gain an intuitive understanding of the language at work. Lexers read the source code and convert it into a stream of tokens, which are the languages building blocks - keywords, operators and literals.
Parsers takes the stream of tokens and builds an Abstract Syntax Tree (AST) representing the structure of the code, where each node represents an expression or statement in the language. Semantics are how a language's expressions are evaluated.

## Interpreted or Compiled

Languages are either interpreted or compiled. Interpreters are slower than compilers; but they offer gretaer flexibilty since they can evaluate code at runtime/
Compilers are faster but with less flexibilty since they require an additional build step.

## Typing & Paradigms

Software languages embrace various typing paradigms, shaping how developers structure and interact with code. Object-oriented languages, organize code around objects and classes. Functional languages, emphasize immutable data and higher-order functions, optimized for parallelism. Procedural languages, focus on procedures and routines to define sequential steps, for efficiency and control. Dynamic typing, allows flexibility by determining variable types at runtime, enabling rapid prototyping and dynamic behavior.

The various paradigms are:

- Procedural
- Object-oriented
- Functional
- Scripting
- Markup
- Query
- Domain-specific

## Security, Performance and Memory Management

Programming languages have varying amounts of support for memory management and protective features.

## Code Examples

## Testing Patterns

## Standard Libraries

Working with files, databases, networking, IDEs, pdb debuggers, versioning.

## Common Frameworks

## Tools and Debuggers

## Case Studies in Production

## Community, maintainers and support

## Related languages
